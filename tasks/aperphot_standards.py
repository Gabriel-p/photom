
import read_pars_file as rpf

import os
from os.path import join, isfile
import sys
import numpy as np

import astropy.units as u
from astropy.io import ascii, fits
from astropy.table import Table, vstack

from photutils import CircularAperture
from photutils import CircularAnnulus
from photutils import aperture_photometry


def in_params():
    """
    Read and prepare input parameter values.
    """
    pars = rpf.main()

    in_path = join(pars['mypath'].replace('tasks', 'input'))
    out_path = in_path.replace('input', 'output')

    # Path to final output file in 'output/' folder.
    out_file = join(out_path, pars['aper_file_out'])

    fits_list, mch_files = [], []
    for line in pars['stnd_obs_fields']:
        # Path to input .fits files.
        f_path = join(in_path, line[0])
        list_temp = []
        if os.path.isdir(f_path):
            for file in os.listdir(f_path):
                f = join(f_path, file)
                if isfile(f):
                    if f.endswith('.fits'):
                        list_temp.append(f)
        if not list_temp:
            print("{}\n No .fits files found in match folder. Exit.".format(
                f_path))
            sys.exit()

        # Store list for this folder.
        print("Files found in '{}/' folder:".format(line[0].strip('/')))
        for fit in list_temp:
            print(" * {}".format(fit.replace(f_path, '')[1:]))
        fits_list.append(list_temp)

        # Path to input .mch files (in ../output/.. folder)
        mch_files.append(join(out_path, line[1]))

    return pars, fits_list, mch_files, out_file


def read_standard_coo(mch_f):
    """
    Read _match.coo file created by 'match', with calibrated photometric
    data on Landolt standard stars, and their coordinates in the system of
    the observed frame.
    """
    # Change 'nan' values for '-999.9' for sources not detected.
    landolt_fl = ascii.read(
        mch_f, fill_values=[('nan', '0', 'x_obs', 'y_obs')])
    landolt_fl['x_obs'].fill_value = -999.9
    landolt_fl['y_obs'].fill_value = -999.9
    landolt_fl = landolt_fl.filled()

    return landolt_fl


def standardMagCol(landolt_fl, filt):
    """
    Separate into individual filters. Return single filter, and color term
    used in the fitting process for that filter.
    """
    if filt == 'U':
        standard_mag = landolt_fl['UB'] + landolt_fl['BV'] + landolt_fl['V']
        standard_col = landolt_fl['UB']
    elif filt == 'B':
        standard_mag = landolt_fl['BV'] + landolt_fl['V']
        standard_col = landolt_fl['BV']
    elif filt == 'V':
        standard_mag = landolt_fl['V']
        standard_col = landolt_fl['BV']
    elif filt == 'R':
        standard_mag = landolt_fl['V'] - landolt_fl['VR']
        standard_col = landolt_fl['VR']
    elif filt == 'I':
        standard_mag = landolt_fl['V'] - landolt_fl['VI']
        standard_col = landolt_fl['VI']

    return list(standard_mag), list(standard_col)


def calibrate_magnitudes(tab, itime=1., zmag=25.):
    tab['cal_mags'] = (zmag - 2.5 * np.log10(tab['flux_fit'] / itime)) * u.mag
    return tab


def instrumMags(f_name, tfilt, hdu_data, exp_time, aper_rad, annulus_in,
                annulus_out):
    """
    Perform aperture photometry for all 'tfilt' standard stars observed in
    the 'hdu_data' file.
    """
    # Coordinates from observed frame.
    positions = zip(*[tfilt['x_obs'], tfilt['y_obs']])
    apertures = CircularAperture(positions, r=aper_rad)
    annulus_apertures = CircularAnnulus(
        positions, r_in=annulus_in, r_out=annulus_out)

    apers = [apertures, annulus_apertures]
    # TODO obtain errors for aperture photometry.

    phot_table = aperture_photometry(hdu_data, apers)
    bkg_mean = phot_table['aperture_sum_1'] / annulus_apertures.area()
    bkg_sum = bkg_mean * apertures.area()
    phot_table['flux_fit'] = phot_table['aperture_sum_0'] - bkg_sum
    phot_table = calibrate_magnitudes(phot_table, itime=exp_time)

    # TODO this should not be necessary:
    # https://github.com/astropy/photutils/issues/637
    # Change weird fluxes for sources outside the frame (-999.9, -999.9)
    # to 'nan'.
    for i, (x, y) in enumerate(phot_table['xcenter', 'ycenter']):
        if x.value < -999. and y.value < -999.:
            phot_table['cal_mags'][i] = np.nan

    return phot_table


def writeAperPhot(out_file, filters):
    """
    """
    tables = []
    for v in filters.values():
        tables.append(Table(zip(*v)))
    aper_phot = Table(
        vstack(tables),
        names=('Filt', 'Stnd_field', 'ID', 'file', 'exp_t', 'A', 'mag',
               'Col_L', 'Mag_L'))

    ascii.write(
        aper_phot, out_file,
        format='fixed_width', delimiter=' ', formats={'mag': '%10.4f'},
        fill_values=[(ascii.masked, 'nan')], overwrite=True)


def main():
    """
    Performs aperture photometry on selected standard fields.

    Requires the '.mch' file generated by the 'match' script.

    Returns zero airmass corrected instrumental magnitudes for each filter.
    """
    pars, fits_list, mch_files, out_file = in_params()

    filters = {'U': [], 'B': [], 'V': [], 'R': [], 'I': []}
    num_stars = {'U': 0, 'B': 0, 'V': 0, 'R': 0, 'I': 0}

    for proc_gr, mch_file in enumerate(mch_files):

        stnd_fl = mch_file.split('/')[-1].split('.')[0]
        print("\nAperture photometry and fit transformation\n"
              "equations for the standard field: {}".format(stnd_fl))

        # Read data for this Landolt field, from '.mch' file.
        landolt_fl = read_standard_coo(mch_file)

        N_star_fld = {'U': 0, 'B': 0, 'V': 0, 'R': 0, 'I': 0}
        # For each observed .fits standard file.
        for fr in fits_list[proc_gr]:
            f_name = fr.split('/')[-1].split('.')[0]
            tfilt = landolt_fl[landolt_fl['frame'] == f_name]

            # Load .fits file.
            hdulist = fits.open(fr)
            # Extract header and data.
            hdr, hdu_data = hdulist[0].header, hdulist[0].data
            filt, exp_time, airmass = hdr[pars['filter_key']],\
                hdr[pars['exposure_key']], hdr[pars['airmass_key']]

            # Obtain instrumental magnitudes for the standard stars in the
            # defined Landolt field, in this observed frame.
            photu = instrumMags(
                f_name, tfilt, hdu_data, exp_time,
                float(pars['aperture']), float(pars['annulus_in']),
                float(pars['annulus_out']))

            N_star = sum(~np.isnan(photu['cal_mags']))
            # Increase number of observed stars.
            num_stars[filt] += N_star
            N_star_fld[filt] += N_star
            print(" {} (F: {}, t: {}, A: {}, N_strs: {}"
                  ")".format(f_name, filt, exp_time, airmass, N_star))

            # Extract data for this filter.
            # TODO HARDCODED: the color terms used in the transformation
            # equations are decided here.
            stand_mag, stand_col = standardMagCol(tfilt, filt)

            # Group frames by filter.
            # Filt  Stnd_field ID  file  exp_t  A   mag  Col_L  Mag_L
            for i, ID in enumerate(tfilt['ID']):
                filters[filt].append(
                    [filt, stnd_fl, ID, f_name, str(exp_time), airmass,
                     photu['cal_mags'][i].value, stand_col[i], stand_mag[i]])

        N_star_sum = sum([_ for _ in N_star_fld.values()])
        print("Stars processed for this field: {}".format(N_star_sum))
        for f, Nf in [(a, b) for a, b in N_star_fld.iteritems()]:
            if Nf > 0:
                print(" Filter {}, stars: {}".format(f, Nf))

    # Remove not observed filters from dictionary.
    filters = {k: v for k, v in filters.iteritems() if v}
    if 'V' not in filters.keys():
        print("  WARNING: Filter V is missing.")
        if 'B' not in filters.keys():
            print("  WARNING: Filter B is missing.")

    print(" ")
    for f, Nf in [(a, b) for a, b in num_stars.iteritems()]:
        if Nf > 0:
            print("Filter {}, processed stars: {}".format(f, Nf))

    print("\nWrite final aperture photometry to output file.")
    writeAperPhot(out_file, filters)


if __name__ == '__main__':
    main()
